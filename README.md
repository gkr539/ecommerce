# ecommerce
1. Run docker-compose up (to set up postgres, kafka and to create topic).
2. Run discovery-server, gateway, config-server, order-servicee and payment-service microservices.
3. Kafka producer will publish messages to batchOrders topic and kafka consumer will listen to this topic.
4. For client-order request, following api end points are available.
        -> localhost:9000/order/createOrder/
        -> localhost:9000/order/cancelOrder/{id}/
        -> localhost:9000/order/updateOrder/{id}/
        -> localhost:9000/order/getOrderById/{id}/
5. For batch-order request, following api end points are available.
        -> localhost:9000/order/createBatchOrder/
        -> localhost:9000/order/updateBatchOrder/{id}/
6. Order-service calls payment-service to verify payment conifirmation.
7. For distributed tracing of requests, Zipkin and sleuth are used.
8. For centralized logging, ELK stack is used.
9. Order-id is generated by encrypting customer’s unique email ID and current time stamp using MD5 algorithm.
10. Distributed architectures have many dependencies. If the application is not isolated from dependency failures or network failures, the application itself is at risk of being taken down. Netflix’s Hystrix or a Circuit Breaker helps by providing protection and control over latency and failures from dependencies, most commonly those accessed over network. It helps stop cascading failures and allows you to fail fast and rapidly recover.

  
        
      
